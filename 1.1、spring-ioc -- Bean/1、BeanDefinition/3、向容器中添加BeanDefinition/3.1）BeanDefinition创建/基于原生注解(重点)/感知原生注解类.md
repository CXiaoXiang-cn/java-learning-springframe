要想被原生注解标注的类被注册为bean definition，需要让容器感知到它们，有两种方式。
-- --
# 一、配置包扫描

Application能自动检测被原生注解标注的类，并注册对应的BeanDefinition实例。但是，需要配置被扫描的包。举个栗子：
被扫描到的类：
```java
@Service 
public class SimpleMovieLister {}
@Repository
public class JpaMovieFinder implements MovieFinder{}
```
## 1）@ComponentScan注解配置包扫描
```java
@Configuration
@ComponentScan(basePackages = "org.example") 
public class AppConfig {}
```
-- --
## 2）<context:component-scan/>标签配置包扫描
```xml
<context:component-scan base-package="org.example"/>
```
<context:component-scan/>标签的隐式功能：
- 启用了<context:annotation-config/>标签，因此当使用<context:component-scan/>标签时一般没必要再加上<context:annotation-config/>标签。
- AutowiredAnnotationBeanPostProcessor和CommonAnnotationBeanPostProcessor被包含。想要不被隐式地包含，需要指定annotation-config属性为false。
-- --
## 3）application.scan()方法显示配置（150~151）

```java
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();   
ctx.scan("com.acme");
```


# 二、配置包扫描规则

默认情况下，所有被@Component、@Repository、@Service、@Contronller、被@Component标注自定义的注解标注的类都会被扫描到，要改变这个默认行为，需要配置包扫描规则。

每个过滤器元素都包含type和expression属性。type属性取值一共有五个：
| Xml Type   | Annotation Type | Description |
| ---------- | --------------- | ----------- |
| annotation(default) | FilterType.ANNOTATION | 注解Class |
| assignable | FilterType.ASSIGNABLE_TYPE     | Class |
| regex      | FilterType.REGEX               | 正则表达式 |
| aspectj    | FilterType.ASPECTJ             | aspectj表达式 |
| custom     | FilterType.CUSTOM              | 实现了`org.springframework.core.type.TypeFilter`接口的类 |

## 1）基于注解配置包扫描规则

使用@ComponentScan注解的 `includeFilters` 和 `excludeFilters`属性。
```java
@Configuration 
@ComponentScan(basePackages = "org.example", 
			   includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),  
			   excludeFilters = @Filter(Repository.class))
public class AppConfig {   // ... }
```

## 2）基于xml配置包扫描规则

使用<context:componentscan>标签的 `<context:include-filter/>` 和 `<context:exclude-filter/>` 子标签。
```xml
<context:component-scan base-package="org.example">   
	<context:include-filter type="regex" expression=".*Stub.*Repository"/> 
	<context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository"/>   </context:component-scan>
```

## 3）禁用默认包扫描规则

禁用包扫描规则后，就禁止了被@Component、@Repository、@Service、@Controller、@RestController、@Configuration注解标注类的自动检测。

基于注解禁用包扫描规则：设置@ComponentScan的 `useDefaultFilters=false` 。
基于xml禁用包扫描规则：设置<context:component-scan/>标签的 `use-default-filters=false` 。

-- --
@Bean方法可以@Component类、@Configuration类的基类中出现，同样@Component类、@Configuration类实现的接口的默认方法也能是@Bean方法。

一个类中可以有多个返回相同类型的@Bean工厂方法，这时，有最多参数依赖的@Bean工厂方法被执行。