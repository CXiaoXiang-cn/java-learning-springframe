

# 相关--loadBeanDefinitionsForBeanMethod()
```java
// BeanMethod类是对@Bean方法的方法元数据和所属的配置类的包装
private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {  
	// 获取@Bean方法所属的配置类
    ConfigurationClass configClass = beanMethod.getConfigurationClass();  
    // 获取@Bean方法的方法元数据
    MethodMetadata metadata = beanMethod.getMetadata();  

    String methodName = metadata.getMethodName();  
  
   // Do we need to mark the bean as skipped by its condition?  
    if (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {  
        configClass.skippedBeanMethods.add(methodName);  
        return;   
    }  
    if (configClass.skippedBeanMethods.contains(methodName)) {  
        return;  
    }  

	// 获取@Bean属性
    AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);  
    ... // Assert
  
    // 获取@Bean注解String[]类型的name属性
    List<String> names = new ArrayList<>(Arrays.asList(bean.getStringArray("name")));  
    // 用户没有显示给定,那么方法名称就是bean的名称
    // 如果用户显示给定了多个,那么除了第一个,接下来的其余名称注册为别名
    String beanName = (!names.isEmpty() ? names.remove(0) : methodName);  
    // Register aliases even when overridden  
    for (String alias : names) {  
        this.registry.registerAlias(beanName, alias);  
    }  
  
    // Has this effectively been overridden before (e.g. via XML)?  
    if (isOverriddenByExistingDefinition(beanMethod, beanName)) {  
        if (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {  
	        throw new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource()
	        .getDescription(), beanName, "Bean name derived from @Bean method '" + beanMethod.getMetadata().getMethodName() + "' clashes with bean name for containing configuration class; please make those names unique!");  
        }  
        return;  
    }  


	
    ConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata, beanName);  
    beanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));  
  
    if (metadata.isStatic()) {  
        // static @Bean method  
        if (configClass.getMetadata() instanceof StandardAnnotationMetadata) {  
            beanDef.setBeanClass(((StandardAnnotationMetadata) configClass.getMetadata()).getIntrospectedClass());  
        }  
        else {  
            beanDef.setBeanClassName(configClass.getMetadata().getClassName());  
        }  
        beanDef.setUniqueFactoryMethodName(methodName);  
    }  
    else {  
	    // instance @Bean method  
        beanDef.setFactoryBeanName(configClass.getBeanName());  
        beanDef.setUniqueFactoryMethodName(methodName);  
    }  
  
    if (metadata instanceof StandardMethodMetadata) {  
        beanDef.setResolvedFactoryMethod(((StandardMethodMetadata) metadata).getIntrospectedMethod());  
    }  
  
    beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);  
	beanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.
	        SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);  
  
   AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);  
  
   Autowire autowire = bean.getEnum("autowire");  
   if (autowire.isAutowire()) {  
      beanDef.setAutowireMode(autowire.value());  
   }  
  
   boolean autowireCandidate = bean.getBoolean("autowireCandidate");  
   if (!autowireCandidate) {  
      beanDef.setAutowireCandidate(false);  
   }  
  
   String initMethodName = bean.getString("initMethod");  
   if (StringUtils.hasText(initMethodName)) {  
      beanDef.setInitMethodName(initMethodName);  
   }  
  
   String destroyMethodName = bean.getString("destroyMethod");  
   beanDef.setDestroyMethodName(destroyMethodName);  
  
   // Consider scoping  
   ScopedProxyMode proxyMode = ScopedProxyMode.NO;  
   AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);  
   if (attributes != null) {  
      beanDef.setScope(attributes.getString("value"));  
      proxyMode = attributes.getEnum("proxyMode");  
      if (proxyMode == ScopedProxyMode.DEFAULT) {  
         proxyMode = ScopedProxyMode.NO;  
      }  
   }  
  
   // Replace the original bean definition with the target one, if necessary  
   BeanDefinition beanDefToRegister = beanDef;  
   if (proxyMode != ScopedProxyMode.NO) {  
      BeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(  
            new BeanDefinitionHolder(beanDef, beanName), this.registry,  
            proxyMode == ScopedProxyMode.TARGET_CLASS);  
      beanDefToRegister = new ConfigurationClassBeanDefinition(  
            (RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata, beanName);  
   }  
  
	... // log
	
    this.registry.registerBeanDefinition(beanName, beanDefToRegister);  
}
```
## isOverriddenByExistingDefinition()
```java
protected boolean isOverriddenByExistingDefinition(BeanMethod beanMethod, String beanName) {  
    if (!this.registry.containsBeanDefinition(beanName)) {  
        return false;  
    }  
    BeanDefinition existingBeanDef = this.registry.getBeanDefinition(beanName);  
  
    // Is the existing bean definition one that was created from a configuration class?  
    // -> allow the current bean method to override, since both are at second-pass level.   
    // However, if the bean method is an overloaded case on the same configuration class,   
    // preserve the existing bean definition.   
    if (existingBeanDef instanceof ConfigurationClassBeanDefinition ccbd) {  
      if (ccbd.getMetadata().getClassName().equals(  
            beanMethod.getConfigurationClass().getMetadata().getClassName())) {  
         if (ccbd.getFactoryMethodMetadata().getMethodName().equals(ccbd.getFactoryMethodName())) {  
            ccbd.setNonUniqueFactoryMethodName(ccbd.getFactoryMethodMetadata().getMethodName());  
         }  
         return true;  
      }  
      else {  
         return false;  
      }  
   }  
  
   // A bean definition resulting from a component scan can be silently overridden  
   // by an @Bean method, as of 4.2...   if (existingBeanDef instanceof ScannedGenericBeanDefinition) {  
      return false;  
   }  
  
   // Has the existing bean definition bean marked as a framework-generated bean?  
   // -> allow the current bean method to override it, since it is application-level   if (existingBeanDef.getRole() > BeanDefinition.ROLE_APPLICATION) {  
      return false;  
   }  
  
   // At this point, it's a top-level override (probably XML), just having been parsed  
   // before configuration class processing kicks in...   if (this.registry instanceof DefaultListableBeanFactory dlbf &&  
         !dlbf.isAllowBeanDefinitionOverriding()) {  
      throw new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),  
            beanName, "@Bean definition illegally overridden by existing bean definition: " + existingBeanDef);  
   }  
   if (logger.isDebugEnabled()) {  
      logger.debug(String.format("Skipping bean definition for %s: a definition for bean '%s' " +  
            "already exists. This top-level bean definition is considered as an override.",  
            beanMethod, beanName));  
   }  
   return true;  
}
```
