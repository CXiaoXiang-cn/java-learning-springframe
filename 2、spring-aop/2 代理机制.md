
参考文档：https://docs.spring.io/spring-framework/reference/core/aop/proxying.html#aop-understanding-aop-proxies

SpringAOP使用JDK动态代理和CGLIB两种代理机制去实现代理。
- 当target对象实现了至少一个接口时，使用JDK动态代理。
- 当target对象没有实现接口时，使用CGLIB。

## 强制使用CGLIB代理

在某些情况下，希望强制使用CGLIB，例如希望代理所有方法，而不仅只代理实现接口的方法。

CGLIB的限制：
- final方法不能被代理。
JDK的限制：
- 只能代理接口中的方法，而不是对非接口实现方法和没有实现接口的类进行代理。

强制CGLIB代理：
针对xml的方式
```xml
<aop:config proxy-target-class="true">
	<!-- other beans defined here... -->
</aop:config>
```
针对@AspectJ自动代理的支持：
```xml
<aop:aspectj-autoproxy proxy-target-class="true"/>
```



# 理解

	参考文档:P377~P

下面是一个普通的、非代理的类：
```java
public class SimplePojo implements Pojo {   
	public void foo() {   
		// this next method invocation is a direct call on the 'this' reference   
		this.bar();
	} 
	public void bar() { 
		// some logic...
	}
}
```
下面是普通的调用：
```java
public static void main(String[] args) {   
	Pojo pojo = new SimplePojo();   
	// this is a direct method call on the 'pojo' reference   
	pojo.foo();
}
```

<img src="D:\Obsidian\note_obsidian\JAVA\pic\普通方法调用.png" alt="普通方法调用.png" width=80%>

下面是对代理对象的调用：
```java
public static void main(String[] args) {   
	ProxyFactory factory = new ProxyFactory(new SimplePojo());   
	factory.addInterface(Pojo.class);   
	factory.addAdvice(new RetryAdvice());   
	Pojo pojo = (Pojo) factory.getProxy();   
	// this is a method call on the proxy!   
	pojo.foo();  }
```
当使用的引用对象是一个代理对象时：
<img src="D:\Obsidian\note_obsidian\JAVA\pic\代理方法执行流程.png" alt="代理方法执行流程.png" width=80%>

# 重点理解

	参考文档:P380~P381

当在客户端代码（此处是main()方法）中访问的是代理对象的引用，因此对该代理对象引用方法的调用是对代理的调用，因此代理能够插入拦截器逻辑。
可是，一旦调用最终抵达了target对象（此处是SimplePojo引用），任何对自身方法的调用（this.bar()和this.foo()）是针对target对象，而非代理对象。这意味着自我调用不会被拦截。

可以按如下方式更改此行为：
```java
public class SimplePojo implements Pojo {
	public void foo() {
		// this works, but... gah!
		((Pojo) AopContext.currentProxy()).bar();
	} 
	public void bar() {
		// some logic... 
	}
}
```
这会让代码与SpringAOP耦合，并且让类意识到自己将被使用到AOP环境下。
上述代码还需要一些额外的配置：
```java
public static void main(String[] args) {
	ProxyFactory factory = new ProxyFactory(new SimplePojo()); 
	factory.addInterface(Pojo.class); 
	factory.addAdvice(new RetryAdvice()); 
	factory.setExposeProxy(true);   // 注意此处
	Pojo pojo = (Pojo) factory.getProxy();
	// this is a method call on the proxy! 
	pojo.foo(); 
}
```
@AspectJ因为不是基于代理实现的框架，所以不存在自我调用的问题。